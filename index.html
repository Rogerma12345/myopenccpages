<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>转换工具</title>
  <style>
    :root { color-scheme: light dark; }
    body {
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial,
        "Noto Sans", "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei UI", "Microsoft YaHei", sans-serif;
      margin: 2rem auto;
      max-width: 980px;
      padding: 0 1rem;
    }
    h1 { font-weight: 700; font-size: 1.35rem; margin: 0 0 1rem; }
    section { border: 1px solid #9993; border-radius: 12px; padding: 1rem; margin: 1rem 0; }
    h2 { font-size: 1.05rem; margin: 0 0 .8rem; }
    label { display: block; margin: .35rem 0 .45rem; font-weight: 650; }
    textarea, input[type="text"] {
      width: 100%;
      padding: .65rem .75rem;
      border: 1px solid #9996;
      border-radius: 10px;
      font-size: .95rem;
      box-sizing: border-box;
      outline: none;
    }
    textarea { min-height: 180px; resize: vertical; }
    button {
      padding: .62rem .9rem;
      border-radius: 10px;
      border: 1px solid #9996;
      background: #eee;
      cursor: pointer;
      white-space: nowrap;
    }
    button:disabled { opacity: .6; cursor: not-allowed; }
    .row {
      display: grid;
      grid-template-columns: 1fr;
      gap: .6rem;
      align-items: center;
      margin-top: .6rem;
    }
    @media (min-width: 820px) {
      .row.cols-2 { grid-template-columns: 1fr 1fr; }
      .row.cols-btn-3 { grid-template-columns: auto auto auto; justify-content: start; }
      .row.cols-btn-2 { grid-template-columns: 1fr auto auto; }
    }
    .note { color: #888; font-size: .9rem; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    .out {
      border: 1px dashed #9996;
      border-radius: 12px;
      padding: .75rem;
      margin-top: .6rem;
      white-space: pre-wrap;
    }
    .ok { color: #1a7f37; font-weight: 650; }
    .err { color: #c00; font-weight: 650; }
    .muted { color: #888; }
  </style>
</head>

<body>
  <h1>文本转换与时间戳工具</h1>

  <!-- 简繁转换 -->
  <section id="secOpenCC">
    <h2>简繁转换</h2>

    <div class="row cols-2">
      <div>
        <label for="ccIn">输入</label>
        <textarea id="ccIn" placeholder="在这里粘贴简体或繁体文本…"></textarea>
      </div>
      <div>
        <label for="ccOut">输出</label>
        <textarea id="ccOut" readonly placeholder="转换结果将显示在这里…"></textarea>
      </div>
    </div>

    <div class="row cols-btn-3">
      <button id="btnS2TWP">简→繁</button>
      <button id="btnT2S">繁→简</button>
      <button id="btnCopyCC">复制输出</button>
    </div>

    <div id="ccMsg" class="out muted">提示：输入文本后选择转换方向。</div>
  </section>

  <!-- 时间戳转换 -->
  <section id="secTime">
    <h2>时间戳转换</h2>

    <label for="tsIn">Unix 时间戳</label>
    <div class="row cols-btn-2">
      <input id="tsIn" type="text" class="mono" placeholder="1592483696789 或 1592483696" autocomplete="off" spellcheck="false" />
      <button id="btnTsToTime">转为时间</button>
      <button id="btnNowTs">填入当前时间</button>
    </div>
    <div id="tsOut" class="out mono muted">输出：—</div>
  </section>
  <!-- URL 拉取 -->
  <section id="secFetch">
    <h2>拉取 URL 内容</h2>

    <label for="fetchUrl">URL</label>
    <input id="fetchUrl" type="text" class="mono" placeholder="https://example.com/data.txt" autocomplete="off" spellcheck="false" />

    <div class="row cols-btn-2">
      <input id="fetchInterval" type="text" class="mono" placeholder="刷新间隔（秒），留空或 0 表示不定时" autocomplete="off" spellcheck="false" />
      <button id="btnFetchNow">立即拉取</button>
      <button id="btnFetchStart">开始定时</button>
    </div>

    <div class="row cols-btn-3">
      <button id="btnFetchStop" disabled>停止</button>
      <button id="btnCopyFetch">复制正文</button>
      <button id="btnClearFetch">清空输出</button>
    </div>

    <div class="row">
      <div>
        <label for="fetchOut">响应正文</label>
        <textarea id="fetchOut" class="mono" readonly placeholder="响应正文将显示在这里…"></textarea>
      </div>
    </div>

    <div id="fetchMsg" class="out muted">提示：目标站点需要允许 CORS 才能读取正文。</div>
  </section>
    <!-- 对话挑战（三选二自动计算） -->
  <section id="secChal">
    <h2>对话挑战</h2>

    <div class="row cols-2">
      <div>
        <label for="chalPlain">明文</label>
        <textarea id="chalPlain" placeholder="粘贴/输入对话明文…"></textarea>
      </div>
      <div>
        <label for="chalCipher">密文</label>
        <input id="chalCipher" type="text" class="mono"
               placeholder="在这里粘贴/显示密文…" autocomplete="off" spellcheck="false" />
        <div class="note">提示：仅填写任意两项，第三项会自动计算。</div>
      </div>
    </div>

    <label for="chalTs">时间戳</label>
    <input id="chalTs" type="text" class="mono" placeholder="例如：1700000000000"
           autocomplete="off" spellcheck="false" />

    <div id="chalMsg" class="out muted">提示：请填写任意两项。</div>
  </section>
  
  <script type="module">
    // OpenCC WASM (Apache-2.0)
    import OpenCC from "https://unpkg.com/opencc-wasm@0.6.1/dist/esm/index.js";

    // Day.js (MIT)
    import dayjs from "https://unpkg.com/dayjs@1.11.19/esm/index.js";
    import utc from "https://unpkg.com/dayjs@1.11.19/esm/plugin/utc/index.js";
    import timezone from "https://unpkg.com/dayjs@1.11.19/esm/plugin/timezone/index.js";
    import relativeTime from "https://unpkg.com/dayjs@1.11.19/esm/plugin/relativeTime/index.js";

    dayjs.extend(utc);
    dayjs.extend(timezone);
    dayjs.extend(relativeTime);

    // ====== UI helpers ======
    const $ = (id) => document.getElementById(id);

    async function copyText(text) {
      const s = String(text ?? "");
      if (!s) return false;
      try {
        await navigator.clipboard.writeText(s);
        return true;
      } catch {
        const ta = document.createElement("textarea");
        ta.value = s;
        ta.style.position = "fixed";
        ta.style.left = "-9999px";
        document.body.appendChild(ta);
        ta.select();
        try { document.execCommand("copy"); } finally { ta.remove(); }
        return true;
      }
    }

    function setBox(el, kind, text) {
      el.className = "out mono " + (kind === "ok" ? "ok" : kind === "err" ? "err" : "muted");
      el.textContent = text;
    }

    // ====== OpenCC converters (create once, reuse) ======
    const ccS2TWP = OpenCC.Converter({ config: "s2twp" });
    const ccT2S   = OpenCC.Converter({ config: "t2s" });

    const ccIn = $("ccIn");
    const ccOut = $("ccOut");
    const ccMsg = $("ccMsg");
    const btnS2TWP = $("btnS2TWP");
    const btnT2S = $("btnT2S");
    const btnCopyCC = $("btnCopyCC");

    async function runConvert(which) {
      const input = ccIn.value ?? "";
      ccOut.value = "";
      btnS2TWP.disabled = btnT2S.disabled = btnCopyCC.disabled = true;
      setBox(ccMsg, "muted", "处理中…");
      try {
        const fn = which === "s2twp" ? ccS2TWP : ccT2S;
        const out = input ? await fn(input) : "";
        ccOut.value = out;
        setBox(ccMsg, "ok", `完成（长度 ${out.length}）`);
      } catch (e) {
        setBox(ccMsg, "err", "转换失败：" + (e?.message ?? e));
      } finally {
        btnS2TWP.disabled = btnT2S.disabled = false;
        btnCopyCC.disabled = false;
      }
    }

    btnS2TWP.addEventListener("click", () => runConvert("s2twp"));
    btnT2S.addEventListener("click", () => runConvert("t2s"));
    btnCopyCC.addEventListener("click", async () => {
      const ok = await copyText(ccOut.value);
      setBox(ccMsg, ok ? "ok" : "err", ok ? "已复制输出" : "复制失败（浏览器权限限制）");
    });

    // ====== Timestamp tools ======
    const tzGuess = dayjs.tz.guess?.() || Intl.DateTimeFormat().resolvedOptions().timeZone || "Local";

    const tsIn = $("tsIn");
    const tsOut = $("tsOut");
    const btnTsToTime = $("btnTsToTime");
    const btnNowTs = $("btnNowTs");

    const FMT = "YYYY-MM-DD HH:mm:ss.SSS";

    function parseEpochLike(s) {
      const raw = String(s ?? "").trim();
      if (!raw) throw new Error("请输入时间戳");
      if (!/^\d+$/.test(raw)) throw new Error("时间戳应为纯数字（秒/毫秒）");

      if (raw.length === 10) return Number(raw) * 1000;
      if (raw.length === 13) return Number(raw);
      const n = Number(raw);
      if (!Number.isFinite(n)) throw new Error("时间戳不是有效数字");
      return n < 1e12 ? n * 1000 : n;
    }

    function prettyFromTs(ms) {
      const dLocal = dayjs(ms);
      const dUtc = dayjs(ms).utc();
      const dTz = dayjs(ms).tz(tzGuess);

      const lines = [
        `毫秒(ms): ${ms}`,
        `秒(s):    ${Math.floor(ms / 1000)}`,
        `本地:     ${dLocal.format(FMT)} (${tzGuess})`,
        `UTC:      ${dUtc.format(FMT)} (UTC)`,
        `ISO:      ${dUtc.toISOString?.() ?? dUtc.format()}`,
        `相对:     ${dLocal.fromNow()}`,
        `时区显示: ${dTz.format(FMT)} (${tzGuess})`,
      ];
      return lines.join("\n");
    }

    btnTsToTime.addEventListener("click", () => {
      try {
        const ms = parseEpochLike(tsIn.value);
        setBox(tsOut, "ok", prettyFromTs(ms));
      } catch (e) {
        setBox(tsOut, "err", "转换失败：" + (e?.message ?? e));
      }
    });

    btnNowTs.addEventListener("click", () => {
      const now = Date.now();
      tsIn.value = String(now);
      setBox(tsOut, "ok", prettyFromTs(now));
    });
    // ====== Fetch URL tools ======
    const fetchUrl = $("fetchUrl");
    const fetchInterval = $("fetchInterval");
    const fetchOut = $("fetchOut");
    const fetchMsg = $("fetchMsg");
    const btnFetchNow = $("btnFetchNow");
    const btnFetchStart = $("btnFetchStart");
    const btnFetchStop = $("btnFetchStop");
    const btnCopyFetch = $("btnCopyFetch");
    const btnClearFetch = $("btnClearFetch");

    const LS_URL = "urlfetch_url";
    const LS_INTERVAL = "urlfetch_interval";
    let fetchTimer = null;
    let inFlight = null; // AbortController

    function readIntervalSeconds() {
      const raw = String(fetchInterval.value ?? "").trim();
      if (!raw) return 0;
      if (!/^\d+$/.test(raw)) throw new Error("刷新间隔应为非负整数（秒）");
      const n = Number(raw);
      if (!Number.isFinite(n) || n < 0) throw new Error("刷新间隔不是有效数字");
      return n;
    }

    function setFetchRunning(running) {
      btnFetchNow.disabled = running;
      btnFetchStart.disabled = running;
      btnFetchStop.disabled = !running;
    }

    function saveFetchPrefs() {
      try {
        localStorage.setItem(LS_URL, String(fetchUrl.value ?? ""));
        localStorage.setItem(LS_INTERVAL, String(fetchInterval.value ?? ""));
      } catch {}
    }

    function loadFetchPrefs() {
      try {
        const u = localStorage.getItem(LS_URL);
        const i = localStorage.getItem(LS_INTERVAL);
        if (u) fetchUrl.value = u;
        if (i) fetchInterval.value = i;
      } catch {}
    }

    function stopFetchTimer(showMsg = true) {
      if (fetchTimer) {
        clearInterval(fetchTimer);
        fetchTimer = null;
      }
      if (inFlight) {
        try { inFlight.abort(); } catch {}
        inFlight = null;
      }
      setFetchRunning(false);
      if (showMsg) setBox(fetchMsg, "muted", "已停止。");
    }

    async function doFetchOnce() {
      const url = String(fetchUrl.value ?? "").trim();
      if (!url) throw new Error("请输入 URL");
      // 基础校验：避免明显无效值
      if (!/^https?:\/\//i.test(url)) throw new Error("URL 需以 http:// 或 https:// 开头");

      saveFetchPrefs();

      // 终止上一次未完成的请求
      if (inFlight) {
        try { inFlight.abort(); } catch {}
        inFlight = null;
      }

      const controller = new AbortController();
      inFlight = controller;

      const timeoutMs = 15000;
      const t0 = Date.now();
      setBox(fetchMsg, "muted", "拉取中…");

      const timer = setTimeout(() => {
        try { controller.abort(); } catch {}
      }, timeoutMs);

      try {
        const res = await fetch(url, {
          method: "GET",
          cache: "no-store",
          redirect: "follow",
          signal: controller.signal,
        });

        const ct = res.headers.get("content-type") || "-";
        const cl = res.headers.get("content-length") || "-";

        const text = await res.text();
        fetchOut.value = text;

        const ms = Date.now() - t0;
        const when = dayjs(Date.now()).format("YYYY-MM-DD HH:mm:ss.SSS");

        const statusLines = [
          `时间: ${when}`,
          `耗时: ${ms} ms`,
          `HTTP: ${res.status} ${res.statusText || ""}`.trim(),
          `Content-Type: ${ct}`,
          `Content-Length(header): ${cl}`,
          `正文长度(字符): ${text.length}`,
        ];

        // HTTP 非 2xx 仍然可能有正文，这里把状态作为提示，不强制当作异常
        setBox(fetchMsg, res.ok ? "ok" : "err", statusLines.join("\n"));
      } catch (e) {
        const when = dayjs(Date.now()).format("YYYY-MM-DD HH:mm:ss.SSS");
        const name = e?.name ?? "Error";
        const msg = e?.message ?? String(e);

        // 常见失败原因提示（不做绕过）
        const hintLines = [
          `时间: ${when}`,
          `错误: ${name}: ${msg}`,
          `说明: 目标站点未开放 CORS、网络不可达、URL 无效、或被浏览器拦截时会失败。`,
          `处置: 需要目标站点返回允许跨域的响应头，或使用你可控的服务端代理转发。`,
        ];
        setBox(fetchMsg, "err", hintLines.join("\n"));
      } finally {
        clearTimeout(timer);
        inFlight = null;
      }
    }

    function startFetchTimer() {
      const sec = readIntervalSeconds();
      if (sec <= 0) throw new Error("刷新间隔需大于 0 秒才可开始定时");
      if (fetchTimer) stopFetchTimer(false);

      setFetchRunning(true);
      setBox(fetchMsg, "muted", `定时已启动：每 ${sec} 秒拉取一次。`);

      // 先立即拉取一次
      doFetchOnce().catch((e) => {
        setBox(fetchMsg, "err", "拉取失败：" + (e?.message ?? e));
      });

      fetchTimer = setInterval(() => {
        doFetchOnce().catch(() => {});
      }, sec * 1000);
    }

    // 绑定事件
    loadFetchPrefs();

    btnFetchNow.addEventListener("click", async () => {
      try {
        setFetchRunning(true);
        await doFetchOnce();
      } catch (e) {
        setBox(fetchMsg, "err", "拉取失败：" + (e?.message ?? e));
      } finally {
        // 若没有启动定时，则恢复按钮
        if (!fetchTimer) setFetchRunning(false);
      }
    });

    btnFetchStart.addEventListener("click", () => {
      try {
        startFetchTimer();
      } catch (e) {
        setBox(fetchMsg, "err", "无法启动定时：" + (e?.message ?? e));
        setFetchRunning(false);
      }
    });

    btnFetchStop.addEventListener("click", () => stopFetchTimer(true));

    btnCopyFetch.addEventListener("click", async () => {
      const ok = await copyText(fetchOut.value);
      setBox(fetchMsg, ok ? "ok" : "err", ok ? "已复制正文" : "复制失败（浏览器权限限制）");
    });

    btnClearFetch.addEventListener("click", () => {
      stopFetchTimer(false);
      fetchOut.value = "";
      setBox(fetchMsg, "muted", "已清空输出。");
    });

    // 页面关闭时停止定时与请求
    window.addEventListener("beforeunload", () => stopFetchTimer(false));
        // ====== Challenge (Plain / Cipher / Timestamp) ======
    const chalPlain = $("chalPlain");
    const chalCipher = $("chalCipher");
    const chalTs = $("chalTs");
    const chalMsg = $("chalMsg");

    // 运行环境检查（WebCrypto 通常需要 HTTPS 或 localhost）
    const hasWebCrypto = !!(globalThis.crypto && crypto.subtle);

    const MOD_1E13 = 10000000000000n;

    function normalizePlain(s) {
      return String(s ?? "").replace(/\r\n/g, "\n").replace(/\r/g, "\n");
    }

    function normalizeTs13(s) {
      const raw = String(s ?? "").trim();
      if (!raw) throw new Error("时间戳为空");
      if (!/^\d+$/.test(raw)) throw new Error("时间戳应为纯数字");
      if (raw.length === 13) return raw;
      if (raw.length === 10) return String(BigInt(raw) * 1000n).padStart(13, "0");
      throw new Error("时间戳应为 13 位毫秒（或 10 位秒）");
    }

    function parseCipherToken(token) {
      const t = String(token ?? "").trim();
      const m = /^(\d{13})-(.+)$/.exec(t);
      if (!m) throw new Error("密文格式错误，应为：13位数字-Base91串");
      return { e13: m[1], p91: m[2] };
    }

    // --- Base91 (basE91) ---
    const B91 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!#$%&()*+,./:;<=>?@[]^_`{|}~"';
    if (B91.length !== 91) throw new Error("Base91 alphabet length mismatch");
    const B91_INV = (() => {
      const m = new Map();
      for (let i = 0; i < B91.length; i++) m.set(B91[i], i);
      return m;
    })();

    function base91Encode(bytes) {
      let b = 0;
      let n = 0;
      let out = "";
      for (let i = 0; i < bytes.length; i++) {
        b |= (bytes[i] & 255) << n;
        n += 8;
        if (n > 13) {
          let v = b & 8191; // 2^13-1
          if (v > 88) {
            b >>= 13;
            n -= 13;
          } else {
            v = b & 16383;  // 2^14-1
            b >>= 14;
            n -= 14;
          }
          out += B91[v % 91] + B91[Math.floor(v / 91)];
        }
      }
      if (n) {
        out += B91[b % 91];
        if (n > 7 || b > 90) out += B91[Math.floor(b / 91)];
      }
      return out;
    }

    function base91Decode(str) {
      const s = String(str ?? "");
      let b = 0;
      let n = 0;
      let v = -1;
      const out = [];
      for (let i = 0; i < s.length; i++) {
        const c = s[i];
        const val = B91_INV.get(c);
        if (val === undefined) throw new Error(`Base91 含非法字符：${c}`);
        if (v < 0) {
          v = val;
        } else {
          v += val * 91;
          b |= v << n;
          n += (v & 8191) > 88 ? 13 : 14;
          while (n >= 8) {
            out.push(b & 255);
            b >>= 8;
            n -= 8;
          }
          v = -1;
        }
      }
      if (v >= 0) {
        b |= v << n;
        n += 7;
        while (n >= 8) {
          out.push(b & 255);
          b >>= 8;
          n -= 8;
        }
      }
      return new Uint8Array(out);
    }

    // --- WebCrypto helpers ---
    const te = new TextEncoder();
    const td = new TextDecoder();

    async function sha256Bytes(u8) {
      const buf = await crypto.subtle.digest("SHA-256", u8);
      return new Uint8Array(buf);
    }

    async function importHmacKey(rawKeyBytes) {
      return crypto.subtle.importKey(
        "raw",
        rawKeyBytes,
        { name: "HMAC", hash: "SHA-256" },
        false,
        ["sign"]
      );
    }

    async function hmacSha256(keyObj, msgBytes) {
      const sig = await crypto.subtle.sign("HMAC", keyObj, msgBytes);
      return new Uint8Array(sig);
    }

    async function keystreamFromTs(ts13, outLen) {
      const keyObj = await importHmacKey(te.encode(ts13));
      const out = new Uint8Array(outLen);
      let off = 0;
      let ctr = 0;
      while (off < outLen) {
        const block = await hmacSha256(keyObj, te.encode(`KS|v1|${ctr}`));
        const n = Math.min(block.length, outLen - off);
        out.set(block.subarray(0, n), off);
        off += n;
        ctr++;
      }
      return out;
    }

    function xorBytes(a, b) {
      const n = Math.min(a.length, b.length);
      const out = new Uint8Array(n);
      for (let i = 0; i < n; i++) out[i] = a[i] ^ b[i];
      return out;
    }

    async function maskFromPlain(plainNorm) {
      const dig = await sha256Bytes(te.encode(plainNorm));
      let x = 0n;
      // 取前 8 字节作为 big-endian 整数
      for (let i = 0; i < 8; i++) x = (x << 8n) + BigInt(dig[i]);
      return x % MOD_1E13;
    }

    async function calcE13(ts13, plainNorm) {
      const t = BigInt(ts13);
      const mask = await maskFromPlain(plainNorm);
      const e = (t + mask) % MOD_1E13;
      return e.toString().padStart(13, "0");
    }

    async function encryptToCipher(plainRaw, tsRaw) {
      if (!hasWebCrypto) throw new Error("当前环境不支持 WebCrypto（需 HTTPS 或 localhost）");
      const plainNorm = normalizePlain(plainRaw);
      const ts13 = normalizeTs13(tsRaw);

      const pBytes = te.encode(plainNorm);
      const chk = (await sha256Bytes(pBytes))[0];
      const data = new Uint8Array(pBytes.length + 1);
      data.set(pBytes, 0);
      data[data.length - 1] = chk;

      const ks = await keystreamFromTs(ts13, data.length);
      const cBytes = xorBytes(data, ks);
      const p91 = base91Encode(cBytes);

      const e13 = await calcE13(ts13, plainNorm);
      return `${e13}-${p91}`;
    }

    async function decryptPlainFromCipher(cipherRaw, tsRaw) {
      if (!hasWebCrypto) throw new Error("当前环境不支持 WebCrypto（需 HTTPS 或 localhost）");
      const { e13, p91 } = parseCipherToken(cipherRaw);
      const ts13 = normalizeTs13(tsRaw);

      const cBytes = base91Decode(p91);
      if (cBytes.length < 2) throw new Error("密文长度异常");

      const ks = await keystreamFromTs(ts13, cBytes.length);
      const data = xorBytes(cBytes, ks);

      const chk = data[data.length - 1];
      const pBytes = data.subarray(0, data.length - 1);

      const dig0 = (await sha256Bytes(pBytes))[0];
      if (dig0 !== chk) throw new Error("校验失败：时间戳或密文不匹配");

      const plainNorm = td.decode(pBytes);

      // 额外一致性检查：e13 是否匹配（能更早发现输入错误）
      const e13Expect = await calcE13(ts13, plainNorm);
      if (e13Expect !== e13) throw new Error("校验失败：密文头与解密结果不一致");

      return plainNorm;
    }

    async function recoverTsFromCipherAndPlain(cipherRaw, plainRaw) {
      if (!hasWebCrypto) throw new Error("当前环境不支持 WebCrypto（需 HTTPS 或 localhost）");
      const { e13 } = parseCipherToken(cipherRaw);
      const plainNorm = normalizePlain(plainRaw);

      const e = BigInt(e13);
      const mask = await maskFromPlain(plainNorm);

      // (e - mask) mod 1e13
      let t = e - mask;
      t %= MOD_1E13;
      if (t < 0n) t += MOD_1E13;

      const ts13 = t.toString().padStart(13, "0");

      // 强校验：用算出来的 ts13 反解密密文，必须得到同一明文
      const plainCheck = await decryptPlainFromCipher(cipherRaw, ts13);
      if (plainCheck !== plainNorm) throw new Error("明文与密文不匹配");

      return ts13;
    }

    // --- UI logic: exactly 2 filled => compute the 3rd; output field becomes readOnly ---
    function isFilledPlain() { return (chalPlain.value ?? "").length > 0; }
    function isFilledCipher() { return String(chalCipher.value ?? "").trim().length > 0; }
    function isFilledTs() { return String(chalTs.value ?? "").trim().length > 0; }

    function setReadOnlyOutput(which /* 'plain'|'cipher'|'ts'|null */) {
      chalPlain.readOnly = false;
      chalCipher.readOnly = false;
      chalTs.readOnly = false;
      if (which === "plain") chalPlain.readOnly = true;
      if (which === "cipher") chalCipher.readOnly = true;
      if (which === "ts") chalTs.readOnly = true;
    }

    let chalTimer = null;
    let chalBusy = false;

    function scheduleChalCompute() {
      if (chalTimer) clearTimeout(chalTimer);
      chalTimer = setTimeout(() => void computeChal(), 180);
    }

    async function computeChal() {
      if (chalBusy) return;
      chalBusy = true;

      try {
        const pHas = isFilledPlain();
        const cHas = isFilledCipher();
        const tHas = isFilledTs();
        const filled = (pHas ? 1 : 0) + (cHas ? 1 : 0) + (tHas ? 1 : 0);

        // 三项都填且没有只读输出：视为“填太多”
        if (filled === 3 && !chalPlain.readOnly && !chalCipher.readOnly && !chalTs.readOnly) {
          setReadOnlyOutput(null);
          setBox(chalMsg, "err", "填写过多：请清空其中一项，只保留两项用于计算。");
          return;
        }

        if (filled === 0) {
          setReadOnlyOutput(null);
          setBox(chalMsg, "muted", "提示：请填写任意两项。");
          return;
        }

        if (filled === 1) {
          setReadOnlyOutput(null);
          setBox(chalMsg, "muted", "还差一项：请再填写一个字段。");
          return;
        }

        // 如果已有只读输出且三项齐全，则保持现状并提示一致性
        if (filled === 3 && (chalPlain.readOnly || chalCipher.readOnly || chalTs.readOnly)) {
          setBox(chalMsg, "ok", "已根据两项计算出第三项。若要改方向，请先清空任意一项再输入。");
          return;
        }

        // filled === 2: 计算缺失项
        if (pHas && tHas && !cHas) {
          setReadOnlyOutput("cipher");
          setBox(chalMsg, "muted", "计算中…");
          const cipher = await encryptToCipher(chalPlain.value, chalTs.value);
          chalCipher.value = cipher;
          setBox(chalMsg, "ok", "成功：已生成密文。");
          return;
        }

        if (cHas && tHas && !pHas) {
          setReadOnlyOutput("plain");
          setBox(chalMsg, "muted", "计算中…");
          const plain = await decryptPlainFromCipher(chalCipher.value, chalTs.value);
          chalPlain.value = plain;
          setBox(chalMsg, "ok", "成功：已解出明文。");
          return;
        }

        if (cHas && pHas && !tHas) {
          setReadOnlyOutput("ts");
          setBox(chalMsg, "muted", "计算中…");
          const ts13 = await recoverTsFromCipherAndPlain(chalCipher.value, chalPlain.value);
          chalTs.value = ts13;
          setBox(chalMsg, "ok", "成功：已解出时间戳（13 位毫秒）。");
          return;
        }

        // 其他情况：用户可能在输出框里输入导致矛盾，解除只读并提示
        setReadOnlyOutput(null);
        setBox(chalMsg, "err", "状态异常：请只保留两项（清空一项），再进行计算。");
      } catch (e) {
        // 出错时解除只读，便于用户修改
        setReadOnlyOutput(null);
        setBox(chalMsg, "err", "失败：" + (e?.message ?? e));
      } finally {
        chalBusy = false;
      }
    }

    chalPlain.addEventListener("input", scheduleChalCompute);
    chalCipher.addEventListener("input", scheduleChalCompute);
    chalTs.addEventListener("input", scheduleChalCompute);

    // 初始提示
    setBox(chalMsg, hasWebCrypto ? "muted" : "err",
      hasWebCrypto
        ? "提示：请填写任意两项，第三项会自动计算。"
        : "当前环境不支持 WebCrypto（通常需要 HTTPS 或 localhost）。"
    );
  </script>
</body>
</html>
